

#define a drone class. It's based on the referenced quadrotor class but with extras
# - Sensing Abilities
# - Planning
# - Commuincation with overmind

from model.quadcopter import Quadcopter

import trajGen3D
import controller
import numpy as np
from utils.utils import RPYToRot, RotToQuat, RotToRPY
import open3d as o3d

dt = 0.01
class Drone(Quadcopter):
    
    def __init__(self, start_state, env = None, knowledge_map = None):
        """Initialize the drone with a start state
        
        start_state: [x, y, z, roll, pitch, yaw]
        """
        
        start_pos = start_state[0]
        start_attitude = start_state[1]
        
        super().__init__(start_pos, start_attitude)

        self.current_position = self.position()
        self.states = [self.current_position] # List of all states the drone has been in

        self.t = 0.0 # Initialize time
        self.t_total = 0.0 # Total time of the simulation
        self.environment = env

        self.sensing_radius = 3 #in points
        self.sensing_resolution = 0.5 #in points
   
    def execute_trajectory(self, waypoints: np.array):
        """ Exucute the trajectory generated by the planner 
        
        Inputs: Waypoints: A list of waypoints to follow
        
        """
        #add the start state to the beginning of the waypoints list
        waypoints = np.vstack((self.current_position, waypoints))
        coeff_x, coeff_y, coeff_z = trajGen3D.get_MST_coefficients(waypoints)
        while self.t < 100:
            # Do the attitudeControl function with the waypoints
            desired_state = trajGen3D.generate_trajectory(self.t, 20.0, waypoints, coeff_x, coeff_y, coeff_z)

            # go to the position
            self.go_to(desired_state)

            #update the current position of the drone
            self.current_position = self.position()
            self.states.append(self.current_position.copy())

            if np.allclose(self.current_position, waypoints[-1], atol=0.1):
                print("Reached the target position")
                return "Goal"
            #survey the environment
            self.survey_environment()

            
            # Catch obstacle collision exceptions
            # if self.check_collision():
            #     print("Collision detected!")
            #     return "Collision"
        self.t_total += self.t
        self.t = 0
        return "Free"
    def survey_environment(self):
        # return a list of every coordinate within sensing range
        # and a list of the status of each coordinate

        # figure out the voxels in the sensing range
        search_range_x = np.arange(self.current_position[0] - self.sensing_radius, self.current_position[0] + self.sensing_radius, self.sensing_resolution)
        search_range_y = np.arange(self.current_position[1] - self.sensing_radius, self.current_position[1] + self.sensing_radius, self.sensing_resolution)
        search_range_z = np.arange(self.current_position[2] - self.sensing_radius, self.current_position[2] + self.sensing_radius, self.sensing_resolution)
        
        search_range = np.array(np.meshgrid(search_range_x, search_range_y, search_range_z)).T.reshape(-1, 3)
        
        # query the environment for status of each voxel
        for point in search_range:
            status = self.environment.query(point)
            current_voxel = o3d.geometry.Voxel()

            if status == "Obstacle":
                current_voxel.color = [1, 0, 0]  # Set color to red
                current_voxel.grid_index = self.environment.detected_obstacles.get_voxel(point)
                self.environment.detected_obstacles.add_voxel(current_voxel)
            elif status == "Free":
                current_voxel.color = [0, 1, 0]  # Set color to green
                current_voxel.grid_index = self.environment.detected_free_space.get_voxel(point)
                self.environment.detected_free_space.add_voxel(current_voxel)
 
        
    def current_voxel(self):
        return self.environment.obstacle_map2.get_voxel(self.current_position)
        #return self.environment.world_to_grid(self.current_position)
    
    

    def check_collision(self):
        """ Return True if the drone is in a voxel with an obstacle """
        if(self.environment.query(self.current_position) == "Obstacle"):
            return True
        else:
            return False

    def go_to(self, desired_state, mode="Trivial"):
        """Go to the desired state """
        
        if(mode == "controlled"):
            F, M = controller.run(self, desired_state)
            self.update(dt, F, M)
        elif(mode == "Trivial"):
            #Trivial implementation for now. Just set the state to the desired state  
            pos_d = desired_state.pos
            vel_d = desired_state.vel
            acc_d = desired_state.acc
            yaw_d = desired_state.yaw
            yawdot_d = desired_state.yawdot

            self.state[0:3] = pos_d
            self.state[3:6] = vel_d
            self.state[6:10] = RotToQuat(RPYToRot(0, 0, yaw_d))


        self.t += dt