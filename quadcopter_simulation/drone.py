

#define a drone class. It's based on the referenced quadrotor class but with extras
# - Sensing Abilities
# - Planning
# - Commuincation with overmind

from model.quadcopter import Quadcopter

import trajGen3D
import controller
import numpy as np
from utils.utils import RPYToRot, RotToQuat, RotToRPY

dt = 0.01
class Drone(Quadcopter):
    
    def __init__(self, start_state, env = None, knowledge_map = None):
        """Initialize the drone with a start state
        
        start_state: [x, y, z, roll, pitch, yaw]
        """
        
        start_pos = start_state[0]
        start_attitude = start_state[1]
        
        super().__init__(start_pos, start_attitude)

        self.current_position = self.position()
        self.states = [] # List of all states the drone has been in

        self.traj_desired = []
        self.t = 0.0 # Initialize time
        self.environment = env
   
    def execute_trajectory(self, waypoints: list):
        """ Exucute the trajectory generated by the planner 
        
        Inputs: Waypoints: A list of waypoints to follow
        
        """
        coeff_x, coeff_y, coeff_z = trajGen3D.get_MST_coefficients(waypoints)
        while self.t < 100:
            # Do the attitudeControl function with the waypoints
            desired_state = trajGen3D.generate_trajectory(self.t, 2.0, waypoints, coeff_x, coeff_y, coeff_z)
            self.traj_desired.append(desired_state.pos)
            # go to the position
            self.go_to(desired_state)

            #update the current position of the drone
            self.current_position = self.position()
            self.states.append(self.current_position.copy())
            #print(self.current_position)   
            if np.allclose(self.current_position, waypoints[-1], atol=0.1):
                print("Reached the target position")
                break
            #survey the environment
            self.survey_environment()

            
            # Catch obstacle collision exceptions
            if self.check_collision():
                #print("Collision detected!")
                break
                
    def survey_environment(self):
        # return a list of every coordinate within sensing range
        # and a list of the status of each coordinate

        # figure out the voxels in the sensing range
        self.sensing_radius = 5
        start_voxel = self.current_voxel()
        search_range_x = np.arange(start_voxel[0] - self.sensing_radius, start_voxel[0] + self.sensing_radius)
        search_range_y = np.arange(start_voxel[1] - self.sensing_radius, start_voxel[1] + self.sensing_radius)
        search_range_z = np.arange(start_voxel[2] - self.sensing_radius, start_voxel[2] + self.sensing_radius)
        
        search_range = np.array(np.meshgrid(search_range_x, search_range_y, search_range_z)).T.reshape(-1, 3)
        
        # query the environment for status of each voxel
        for voxel in search_range:
            status = self.environment.query(voxel.tolist())
            #print("Voxel: ", voxel, "Status: ", status)

            #self.inform_overmind(voxel, status)

        
    def current_voxel(self):
        return self.environment.world_to_grid(self.current_position)

    def check_collision(self):
        """ Return True if the drone is in a voxel with an obstacle """
        if self.environment.query(self.current_voxel()) == "Obstacle":
            return True
        else:
            return False

    def go_to(self, desired_state, mode="Trivial"):
        """Go to the desired state """
        
        if(mode == "controlled"):
            F, M = controller.run(self, desired_state)
            self.update(dt, F, M)
        elif(mode == "Trivial"):
            #Trivial implementation for now. Just set the state to the desired state  
            pos_d = desired_state.pos
            vel_d = desired_state.vel
            acc_d = desired_state.acc
            yaw_d = desired_state.yaw
            yawdot_d = desired_state.yawdot

            self.state[0:3] = pos_d
            self.state[3:6] = vel_d
            self.state[6:10] = RotToQuat(RPYToRot(0, 0, yaw_d))


        self.t += dt